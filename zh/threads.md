##Java 线程

####11. 进程与线程的区别 ?
进程是一个程序的执行(即正在运行的程序), 然而线程是在进程中独立的执行序列. 一个进程可以包含很多线程. 线程有时被称为轻量级的进程.

####12. 说下创建线程的不同方式. 你倾向于哪种方式并说明原因 ?
有三种创建线程的方式:
* 继承Thread类.
* 实现Runnable接口.
* 通过Executor框架创建线程池.

首选方式是实现Runnable接口, 因为它不需要继承Thread类. 当你的程序设计需要多继承时, 使用接口会有所帮助. 另外, 线程池效率是很高的, 并且实施起来也很简单.

####13. 解释下可用的线程状态.
在执行期间, 线程会处于以下状态中的一种:
* Runnable: 线程已准备就绪, 但没有立即运行.
* Running: 处理器正在执行的线程代码.
* Waiting: 处于阻塞状态的线程, 等待外部某种处理的结束.
* Sleeping: 被强制休眠的线程.
* Blocked on I/O: 等待I/O操作的完成.
* Blocked on Synchronization: 等待取得线程锁.
* Dead: 线程已经执行结束.

####14. 同步方法与同步块的区别 ?
在Java程序中, 每个对象都拥有一个锁. 线程可以通过使用synchronized关键字来获取一个对象上的锁. synchronized关键字可以用于方法级别(粗粒度锁)或代码块级别(细粒度锁).

####15. 在监视器中的线程同步是怎样发生的? 你可以使用哪些级别的同步 ?
JVM使用结合了监视器的锁. 监视器是一个守护者, 它看管一个同步代码的序列, 并且确保在一个时刻只能有一个线程执行同步代码片段. 每个监视器关联着一个对象引用. 只能得到锁的线程才可以执行同步代码.

####16. 什么是死锁 ?
当[两个进程相互等待对方执行完毕](http://www.javacodegeeks.com/2013/01/java-deadlock-example-how-to-analyze-deadlock-situation.html)时, 其结果是它们会永远等待下去.

####17. 怎样确保N个线程访问N个资源时不会发生死锁 ?
使用N个线程时一个非常简单的避免死锁的方法是为所有的锁排序, 并强制每个线程也按那种方式排序. 这样, 如果所有线程以相同的顺序锁定和解锁互斥资源就不会发生死锁了.